# CS 110L: Safety in Systems Programming

[斯坦福大学：系统编程的安全性]((https://web.stanford.edu/class/cs110l/))

### 内存安全和 Rust 基础知识

- 什么是内存安全？为什么在 C 和 C++ 中存在内存安全问题？
- 可以使用哪些工具来查找 C/C++ 代码中的问题？
- 其他编程语言如何帮助我们避免在程序中出错？
- Rust 的内存模型：所有权、生命周期、引用（智能指针&借用）
- C++ 中的 [RAII](https://zh.wikipedia.org/zh-cn/RAII)，以及它与 Rust 的比较

> RAII: Resource Acquisition Is Initialization, 资源获取即初始化

### 如何构建好的代码？

- `null` 的陷阱；以及 Rust 中的 `Option` & `Result`
- Rust 中的枚举
- 不同的抽象方式：面向特征（`trait`）/协议编程 vs. 面向对象编程

### 避免多进程陷阱

- 管道（pipe）的管理：如何避免资源泄漏?
- 信号处理：为什么这么难做好？怎样才能做得更好？

### 避免多线程陷阱

- 在线程上下文中重新审视内存安全
- 如何使用 Rust 的内存模型来防止竞争条件？什么情况下又防止不了？
- 锁（Mutexes）, 自动引用计数智能指针（arc pointers）, 信号量（semaphores）, 条件变量（condition variables）
- 消息传递作为传统共享内存的替代方案

### 实验课：网络系统

- 处理和发送 HTTP 请求
- 实现多线程服务器
- 分布式系统中的负载平衡、故障处理
- 非阻塞 I/O； Rust 中的 async/await和`future`

## 课程讲义

- [x] [#01: Welcome to CS 110L](https://web.stanford.edu/class/cs110l/slides/lecture-01.pdf)
- [x] [#02: Program Analysis](https://web.stanford.edu/class/cs110l/slides/lecture-02.pdf)
    - 动态分析（Dynamic Analysis）
        - Fuzzing，模糊测试
        - [llvm - libFuzzer](https://llvm.org/docs/LibFuzzer.html)
        - [Google - OSS-Fuzz](https://github.com/google/oss-fuzz)
    - 静态分析（Static Analysis）
        - "linting", [llvm - clang-tidy](https://clang.llvm.org/extra/clang-tidy/)
        - 数据流（Dataflow）分析，分支判断
        - 局限：上下文有限，实际场景下很多问题都无法被发现
    - Precondition & Postcondition, 一致性维护，e.g: `strncpy()`
        - C/C++ 语言中，这种一致性维护保证取决于开发者，是否能够让编译器/静态分析器保证？
        - 关键：C 语言诸多条件无法表达
    - 类型系统（Type System）
        - C 语言类型系统：**Simple != easy**
        - 如何通过类型系统在代码中表达&维护前/后置条件？
        - Next：Meet [Rust 🦀️](../../programming-languages/rust/rust.md)
- [ ] [#03: Memory Safety](https://web.stanford.edu/class/cs110l/slides/lecture-03.pdf)
    - [ ] [Lecture notes](https://web.stanford.edu/class/cs110l/lecture-notes/lecture-03/)

## 随堂练习

- [🚀] [Week 1 Exercises](https://web.stanford.edu/class/cs110l/assignments/week-1-exercises/)
    - 认识 C/C++ 中代码分析工具的局限性
    - Static analysis: `clang-tidy`
    - Dynamic analysis: `Valgrind`、`sanitizers`
    - 认识 Make 编译系统：
        - 定义参数变量：
            - `CC` 和 `CXX` 指定 C/C++ 编译器，
            - `CFLAGS` 和 `CXXFLAGS` 指定编译器传参
            - `LDFLAGS` 指定链接器传参
        - 定义执行目标：
            - `default` 默认执行
        - 晦涩、艰深，但可行。有更多现代编译系统替代。
    - 更新 Makefile 支持 sanitizers