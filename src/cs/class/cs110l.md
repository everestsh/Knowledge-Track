# CS 110L: Safety in Systems Programming

[斯坦福大学：系统编程的安全性](https://web.stanford.edu/class/cs110l/)

### 内存安全和 Rust 基础知识

- 什么是内存安全？为什么在 C 和 C++ 中存在内存安全问题？
- 可以使用哪些工具来查找 C/C++ 代码中的问题？
- 其他编程语言如何帮助我们避免在程序中出错？
- Rust 的内存模型：所有权、生命周期、引用（智能指针&借用）
- C++ 中的 [RAII](https://zh.wikipedia.org/zh-cn/RAII)，以及它与 Rust 的比较

> RAII: Resource Acquisition Is Initialization, 资源获取即初始化

### 如何构建好的代码？

- `null` 的陷阱；以及 Rust 中的 `Option` & `Result`
- Rust 中的枚举
- 不同的抽象方式：面向特征（`trait`）/协议编程 vs. 面向对象编程

### 避免多进程陷阱

- 管道（pipe）的管理：如何避免资源泄漏?
- 信号处理：为什么这么难做好？怎样才能做得更好？

### 避免多线程陷阱

- 在线程上下文中重新审视内存安全
- 如何使用 Rust 的内存模型来防止竞争条件？什么情况下又防止不了？
- 锁（Mutexes）, 自动引用计数智能指针（arc pointers）, 信号量（semaphores）, 条件变量（condition variables）
- 消息传递作为传统共享内存的替代方案

### 实验课：网络系统

- 处理和发送 HTTP 请求
- 实现多线程服务器
- 分布式系统中的负载平衡、故障处理
- 非阻塞 I/O； Rust 中的 async/await和`future`

## 课程讲义

- [x] [#01: Welcome to CS 110L](https://web.stanford.edu/class/cs110l/slides/lecture-01.pdf)
- [x] [#02: Program Analysis](https://web.stanford.edu/class/cs110l/slides/lecture-02.pdf)
    - 动态分析（Dynamic Analysis）
        - Fuzzing，模糊测试
        - [llvm - libFuzzer](https://llvm.org/docs/LibFuzzer.html)
        - [Google - OSS-Fuzz](https://github.com/google/oss-fuzz)
    - 静态分析（Static Analysis）
        - "linting", [llvm - clang-tidy](https://clang.llvm.org/extra/clang-tidy/)
        - 数据流（Dataflow）分析，分支判断
        - 局限：上下文有限，实际场景下很多问题都无法被发现
    - Precondition & Postcondition, 一致性维护，e.g: `strncpy()`
        - C/C++ 语言中，这种一致性维护保证取决于开发者，是否能够让编译器/静态分析器保证？
        - 关键：C 语言诸多条件无法表达
    - 类型系统（Type System）
        - C 语言类型系统：**Simple != easy**
        - 如何通过类型系统在代码中表达&维护前/后置条件？
        - Next：Meet [Rust 🦀️](../../programming-languages/rust/rust.md)
- [x] [#03: Memory Safety](https://web.stanford.edu/class/cs110l/slides/lecture-03.pdf)
    - [x] [Lecture notes](https://web.stanford.edu/class/cs110l/lecture-notes/lecture-03/)
    - 内存泄漏（Memory Leaks）：扩容时，旧数据内存没有释放
    - 重复释放（Double Free）：数据内存缓冲区被多次释放
    - 悬垂指针（Dangling Pointers）： 返回栈上的指针，但指向的内存已被释放
        - 迭代器失效（Iterator Invalidation）：旧容器指针由于扩容等原因被释放
    - 什么是良好的代码？
        - 前置/后置条件对于将代码分解为具有明确定义的接口的小块至关重要
        - 开发者的职责则是维护好这些前置/后置条件
    - 良好的内存管理
        - 何时释放内存？
            - 释放得太早，其他代码可能通过指针访问到已被释放的内存
            - 不释放或释放得太晚，则会造成内存泄漏
        - 良好的 C/C++ 代码会清晰定义内存是如何被传递以及释放的职责
            - 注释中常常以“ownership”标记内存所有者
    - 类型系统
        - 是否有能够更好指定前置/后置条件的类型系统支持的编程语言？（Meet Rust🦀️）
    - 所有权
        - 什么是所有权？（指针和绑定的内存对象之间的关系
        - 同一时刻：1对1
        - 指针作用域不存在，在其拥有所有权的内存对象就会被释放
    - 借用
        - 临时引用内存对象
    - 资料
        - [x] [Graphical depiction of ownership and borrowing in Rust](https://rufflewind.com/2017-02-15/rust-move-copy-borrow)
        - [x] [for loops in Rust](http://xion.io/post/code/rust-for-loop.html)
        - [x] [Rust Book - Ownership and Lifetimes](https://doc.rust-lang.org/nomicon/ownership.html)
- [x] [#04: Ownership continued](https://web.stanford.edu/class/cs110l/slides/lecture-04.pdf)
    - Ownership in Memory
        - `Drop`特性
        - 转移所有权时浅拷贝变量「Shadow copy」,并将之前的变量弃用,避免「Double free」
        - 深拷贝,采用`clone`方法
        - Rust 中部分类型的值直接在栈上存储,不用堆(integer types (u32), booleans)
        - 这些类型通常都默认实现了`Copy`特性
        - 如果拥有了`Copy`特性,则不能同时拥有`Drop`特性
        - 没有`Copy`特性,则默认所有权将转移
    - Borrowing++
        - Rust 中的变量默认不可变,须`mut`指定可变
        - `&`(Borrowing)创建引用类型(Reference)
        - 引用规则:多个不可变引用或仅有一个可变引用
    - 所有权机制和借用规则,可在编译时避免诸多内存问题
## 随堂练习

- [x] [Week 1 Exercises](https://web.stanford.edu/class/cs110l/assignments/week-1-exercises/)
    - 认识 C/C++ 中代码分析工具的局限性
    - Static analysis: `clang-tidy`
    - Dynamic analysis: `Valgrind`、`sanitizers`
    - 认识 Make 编译系统：
        - 定义参数变量：
            - `CC` 和 `CXX` 指定 C/C++ 编译器，
            - `CFLAGS` 和 `CXXFLAGS` 指定编译器传参
            - `LDFLAGS` 指定链接器传参
        - 定义执行目标：
            - `default` 默认执行
        - 晦涩、艰深，但可行。有更多现代编译系统替代。
    - 更新 Makefile 支持 sanitizers
        - `-fsanitize=address,leak,undefined` flag
    - 模糊测试，开启 libFuzzer
        - `-fsanitize=fuzzer,address,leak,undefined` flag